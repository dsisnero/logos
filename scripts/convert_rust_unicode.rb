#!/usr/bin/env ruby
# Convert Rust Unicode tables to Crystal format
# Fixed version with proper Crystal constants

def parse_char(str)
  # Handle Unicode escape \u{XXXX}
  return str[3...-1].to_i(16) if str.start_with?('\\u{')

  # Handle common escape sequences
  return "\t".ord if str == '\\t'
  return "\n".ord if str == '\\n'
  return "\r".ord if str == '\\r'
  return "\f".ord if str == '\\f'
  return "\v".ord if str == '\\v'
  return "\b".ord if str == '\\b'
  return '\\'.ord if str == '\\\\'
  return "'".ord if str == "\\'"
  return '"'.ord if str == '\\"'
  return "\0".ord if str == '\\0'

  # Handle hex escape \xHH
  return Regexp.last_match(1).to_i(16) if str =~ /\\x([0-9a-fA-F]{2})/

  # It's a single character literal (could be multi-byte)
  # Remove surrounding backslash if present (e.g., '\'' becomes "'")
  str = str[1..-1] if str.start_with?('\\') && str.size == 2
  str.ord
end

def convert_file(rust_file, output_file, module_name)
  content = File.read(rust_file)

  # Find all pub const X: &'static [(char, char)] = [...];
  constants = {}

  # Match pub const X: &'static [(char, char)] = &[...];
  # Handles both single-line and multi-line definitions
  content.scan(/pub const ([A-Z_]+): &'static \[\(char, char\)\]\s*=\s*&\s*\[([\s\S]*?)\];/) do |const_name, ranges_text|
    ranges = []
    # Parse ranges like ('A', 'Z') or ('\u{XXXX}', '\u{YYYY}')
    ranges_text.scan(/\(\s*'([^']+)'\s*,\s*'([^']+)'\s*\)/) do |start_str, end_str|
      start_cp = parse_char(start_str)
      end_cp = parse_char(end_str)
      ranges << [start_cp, end_cp]
    rescue StandardError
      warn "Warning: Could not parse range: ('#{start_str}', '#{end_str}') in #{const_name}"
    end

    constants[const_name] = ranges if ranges.any?
  end

  # Find BY_NAME mapping if it exists
  by_name = {}
  if content =~ /pub const BY_NAME: &'static \[\(&'static str, &'static \[\(char, char\)\]\)\] = &\[([\s\S]*?)\];/
    by_name_text = Regexp.last_match(1)
    by_name_text.scan(/\("([^"]+)", ([A-Z_]+)\)/) do |name, const_name|
      by_name[name.downcase.gsub(/[_-]/, '')] = const_name
    end
  end

  # Generate Crystal code
  output = []
  output << "# This file is automatically generated from #{File.basename(rust_file)}"
  output << '# DO NOT EDIT THIS FILE DIRECTLY'
  output << ''
  output << "module Regex::Syntax::UnicodeTables::#{module_name}"
  output << ''

  # Generate constants first (Crystal needs them defined before use)
  constants.each do |const_name, ranges|
    crystal_const_name = const_name.upcase
    output << "  # #{const_name.tr('_', ' ')}"
    output << "  #{crystal_const_name} = ["
    ranges.each do |start_cp, end_cp|
      output << "    0x#{start_cp.to_s(16).upcase}_u32..0x#{end_cp.to_s(16).upcase}_u32,"
    end
    output << '  ]'
    output << ''
  end

  # Add BY_NAME mapping if we found it
  if by_name.any?
    output << '  # Mapping from normalized property names to range arrays'
    output << '  BY_NAME = {'
    by_name.each do |name, const_name|
      crystal_const_name = const_name.upcase
      output << "    \"#{name}\" => #{crystal_const_name},"
    end
    output << '  }'
  else
    # Create BY_NAME from all constants (for tables like general_category that don't have BY_NAME in Rust)
    output << '  # Mapping from normalized property names to range arrays'
    output << '  BY_NAME = {'
    constants.each do |const_name, _|
      normalized_name = const_name.downcase.delete('_')
      crystal_const_name = const_name.upcase
      output << "    \"#{normalized_name}\" => #{crystal_const_name},"
    end
    output << '  }'
  end

  output << ''
  output << 'end'

  File.write(output_file, output.join("\n"))
  puts "Generated #{output_file} with #{constants.size} constants"
end

if __FILE__ == $0
  require 'fileutils'

  if ARGV.length < 2
    puts 'Usage: ruby scripts/convert_rust_unicode_fixed.rb <rust_file> <module_name> [output_file]'
    puts ''
    puts 'Examples:'
    puts '  ruby scripts/convert_rust_unicode_fixed.rb vendor/regex-syntax/regex-syntax/src/unicode_tables/script.rs Script lib/regex-syntax/src/regex/syntax/unicode_tables/script.cr'
    puts '  ruby scripts/convert_rust_unicode_fixed.rb vendor/regex-syntax/regex-syntax/src/unicode_tables/general_category.rs GeneralCategory lib/regex-syntax/src/regex/syntax/unicode_tables/general_category.cr'
    exit 1
  end

  rust_file = ARGV[0]
  module_name = ARGV[1]
  output_file = ARGV[2] || "#{module_name.downcase}.cr"

  unless File.exist?(rust_file)
    puts "Error: Rust file not found: #{rust_file}"
    exit 1
  end

  # Create output directory if it doesn't exist
  FileUtils.mkdir_p(File.dirname(output_file))

  convert_file(rust_file, output_file, module_name)
end
